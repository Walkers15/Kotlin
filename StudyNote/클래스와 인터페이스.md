---


---

<h1 id="클래스와-인터페이스">클래스와 인터페이스</h1>
<blockquote>
<p>추상 클래스, 데이터 클래스, 중첩 클래스, 이너 클래스, 실드 클래스, 열거형 클래스, 인터페이스</p>
</blockquote>
<h2 id="추상-클래스와-인터페이스">추상 클래스와 인터페이스</h2>
<h4 id="추상-클래스-vs-인터페이스">추상 클래스 vs 인터페이스</h4>
<p>추상 클래스는 프로퍼티에 상태 정보를 저장할 수 있다.<br>
인터페이스는, 하위 클래스에서 여러개의 인터페이스를 구현하는 다중 상속이 가능하다.</p>
<h3 id="추상-클래스">추상 클래스</h3>
<p><strong>abstract</strong> 키워드와 함께 사용한다.<br>
추상 클래스로부터 일반적인 객체를 생성하는 방법으로 인스턴스화될 수 없다.<br>
즉, 직접 인스턴스화 하지 않고 다만 상속받을 클래스들에서 어떻게 구현해야 하는지를 나타내는 용도로 사용된다.</p>
<p>클래스 내의 프로퍼티나 메소드도 abstract로 선언할 수 있다. 하지만 만일 클래스 내에 해당 사항이 하나라도 있다면, 클래스는 abstract로 선언되어야 한다.<br>
주로 연관성이 높은 사항(ex. 자동차의 경우 Vehicle 추상 클래스를 만들어 기본 정보를 담고, SUV, 트랙터 등 다양한 자동차에서 파생되는 것들을 Vehicle 클래스를 상속받아 만든다.)을 담아둘 때 사용하면 좋다.</p>
<p>추상 클래스 내의 추상 프로퍼티, 메소드는 반드시 하위 클래스에서 재정의해서 초기화해야 한다.<br>
하지만 var year = "2018"과 같이 abstract로 선언하지 않은 프로퍼티와 메소드들은, 하위 클래스에서 재정의할 필요가 없다.</p>
<p>abstract 키워드를 사용하면, 상위 클래스에 open 키워드를 사용하지 않아도 된다.<br>
하위 클래스에서 재정의할때는 <strong>override</strong> 키워드를 사용해야 한다.</p>
<p>추상클래스에서 하위 클래스를 생성하지 않고 단일 인스턴스로 객체를 생성하려면 <strong>object</strong>키워드를 사용하면 된다.</p>
<h3 id="인터페이스">인터페이스</h3>
<p>인터페이스에는 abstract로 정의된 추상 메서드나 일반 메서드가 포함된다.<br>
<strong>메서드에 구현 내용이 포함될 수 있다.</strong><br>
추상 클래스와 다르게 <strong>선언만</strong> 가능하다.<br>
인터페이스 - 구현 클래스<br>
인터페이스는 원하는 만큼 구현 클래스에 붙여서 필요한 메서드를 구현해 내면 됨.<br>
다음과 같은 형태로 구현한다.</p>
<pre><code>interface 인터페이스명[:인터페이스 이름//인페&gt;인페 구현가능]{
	추상 프로퍼티 선언//이때 추상 클래스와 다르게 abstract 키워드가 필요없음
	추상 메소드 선언
	[일반 메서드 선언{...}]
}
</code></pre>
<p>인터페이스를 구현할 때 추상적으로 적의한 프로퍼티와 메소드 앞에 override 키워드를 사용해 구현한다.<br>
프로퍼티에는 값을 저장할 수 없지만, val로 저장된 프로퍼티는 게터를 통해 필요한 내용을 구현할 수 있다.<br>
open class와 interface / abstract class 와 interface / interface와 interface 등, 다양한 상위 클래스와 함께 사용할 수 있다.<br>
<code>class Dog(name: String, overrude var category: String) : Animal(name), Pet{...}</code><br>
이 때 두 상위 클래스에 겹치는 이름의 메소드가 있다면, 앵클 브레킷을 이용하여 호출할 수 있음<br>
<code>super&lt;인터페이스 or 클래스명&gt;.메소드 이름</code>의 형태</p>
<p>인터페이스를 이용하면 특정 구현에 의존적이지 않은 코드를 만들 수 있음.</p>
<h2 id="데이터-클래스와-기타-클래스들">데이터 클래스와 기타 클래스들</h2>
<p>데이터 클래스 : 일반적인 클래스가 가지는 구현부에 대한 자원의 낭비를 막고 오로지 데이터 저장에 초점을 맞추기 위해 고안된 클래스<br>
그 외 : 이너 클래스, 실드 클래스, 열거형 클래스</p>
<h3 id="데이터-전달을-위한-데이터-클래스">데이터 전달을 위한 데이터 클래스</h3>
<p>DTO : 데이터 전달을 위한 객체<br>
앞서 봤던 것처럼, 자바의 POJO와는 달리 코틀린의 클래스는 프로퍼티에 대한 게터. 세터등을 내부적으로 생성하기 때문에, 데이터 클래스에 게터,세터,equals()같은 메서드를 직접 만들 필요가 없다. 자동으로 생성해주는 메소드들은 다음과 같다.</p>
<pre><code>1. 프로퍼티를 위한 게터/세터
2. 비교를 위한 equals() 와 키 사용을 위한 hashCode()
3. 프로퍼티를 문자열로 변환해 순서대로 보여주는 toString()
4. 객체 복사를 위한 copy()
5. 프로퍼티에 상응하는 component1(), component2() 등
</code></pre>
<p>DTO는 일종의 표준과 같은 규칙을 정하면, 전송하거나 받고자 하는 어떤 요소든 데이터를 쉽게 다룰 수 있기 때문에 사용한다.<br>
다음과 같이 선언하며, 다음과 같은 규칙이 있다.</p>
<pre><code>data class Custiomer(var name: String, var email:String)

1. 주 생성자는 최소한 하나의 매개변수를 가져야 한다.
2. 주 생성자의 모든 매개변수는 val, var로 지정된 프로퍼티여야 한다.
3. 데이터 클래스는 abstract, open, sealed, inner 키워드를 사용할 수 없다.
</code></pre>
<h4 id="copy-메소드-사용하기">copy() 메소드 사용하기</h4>
<p>copy는 데이터 객체를 복사하되 다른 프로퍼티 값을 가지는 것만 명시하여 변경할 수 있다.</p>
<h4 id="객체-디스트럭쳐링하기">객체 디스트럭쳐링하기</h4>
<p>디스트럭처링 한다는 것은 객체가 가지고 있는 프로퍼티를 개별 변수로 분해하여 할당하는 것을 말한다.<br>
<code>val (name, email) = cus1</code> 언더스코어를 이용하여 필요하지 않은 프로퍼티는 가져오지 않을 수 있다.<br>
<code>val name = cus1.component1()</code> 처럼 사용하여 개별적으로 프로퍼티를 가져올 수도 있다.</p>
<h3 id="내부-클래스-기법">내부 클래스 기법</h3>
<p>중첩 클래스와 이너 클래스를 내부 클래스라고 한다.<br>
이너 클래스는 외부 클래스의 필드에 접근할 수 있지만, 중첩 클래스는 접근할 수 없다.</p>
<h4 id="중첩-클래스">중첩 클래스</h4>
<p>중첩 클래스는 class <strong>Nested</strong>{…}의 형태로 선언하여 만든다.<br>
중첩 클래스를 사용하면 기본적으로 static으로 다뤄지므로, 클래스의 외부(main)등에서 객체 생성 없이 Outer.Nested().greeting() 처럼 사용할 수 있다.<br>
중첩 클래스에서도 바깥 클래스의 컴패니언 객체의 데이터들에는 접근할 수 있다.</p>
<h4 id="이너-클래스">이너 클래스</h4>
<p>바깥 클래스의 데이터에 접근하는 또 다른 방법으로는 이너 클래스 사용이 있다.<br>
<strong>inner</strong>키워드를 사용하여 만든다.<br>
클래스 안에 이너 클래스를 정의할 수 있는데, 이 때 이너 클래스는 private멤버까지도 접근이 가능하다.</p>
<h4 id="지역-클래스">지역 클래스</h4>
<p>지역 클래스는 특정 메소드의 블록이나 init블록과 같이, 한 블록 범위 안에서만 유효한 클래스이다.<br>
바깥 클래스의 프로퍼티에 접근할 수 있다.</p>
<h4 id="익명-객체">익명 객체</h4>
<p><strong>object</strong>키워드를 사용하여, 일회성으로 객체를 생성해 사용할 수 있다.<br>
인터페이스를 구현하거나 할 때 사용된다.</p>
<h3 id="실드-클래스와-열거형-클래스">실드 클래스와 열거형 클래스</h3>
<p>실드란 무언가 안전하게 보관하기 위해 묶어 두는 것을 말한다.<br>
실드 클래스는 미리 만들어 놓은 자료형들을 묶어서 제공하기 때문에, 열거형의 확장이라고도 할 수 있다.</p>
<h4 id="실드-클래스">실드 클래스</h4>
<p><strong>sealed class</strong>키워드로 클래스를 선언하여 사용한다.<br>
실드 클래스 그 자체는 abstract하여 인스턴스를 만들 수 없다.<br>
생성자도 기본적으로  <strong>private</strong>이며 private 이외의 다른 생성자는 허용하지 않는다.<br>
실드 클래스는 특정 객체 자료형에 따라 when문과 is에 의해 선택적으로 실행할 수 있다.</p>
<h4 id="열거형-클래스">열거형 클래스</h4>
<p>여러 개의 상수를 선언하고 열거된 값을 조건에 따라 선택할 수 있는 특수한 클래스</p>

