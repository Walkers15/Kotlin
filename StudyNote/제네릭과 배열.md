---


---

<h1 id="제네릭과-배열">제네릭과 배열</h1>
<blockquote>
<p>자료형을 일반화해 내부에서 그 자료형에 맞춰 교체하는 방법 &lt;T&gt;</p>
</blockquote>
<h2 id="제네릭-다루기">제네릭 다루기</h2>
<p>제네릭은 클래스 내부에서 사용할 자료형을 나중에 인스턴스를 생성할 때 확정한다.<br>
제네릭을 사용하면 객체의 자료형을 컴파일할 때 체크하기 때문에, 객체 자료형의 안정성을 높이고 형 변환의 번거로움이 줄어든다.</p>
<h3 id="제네릭의-일반적인-사용-방법">제네릭의 일반적인 사용 방법</h3>
<p>앵글 브레킷 <strong>&lt;&gt;</strong> 사이에 형식 매개변수를 넣어 선언한다.<br>
이때 형식 매개변수는 하나 이상 지정할 수 있다.<br>
형식 매개변수는 자료형을 대표하는 용어로, T와 같이 특정 영문의 대문자로 사용한다.<br>
제네릭을 이용함으로써, 의도하지 않은 자료형의 객체를 지정하는 것을 막고, 객체를 사용할 때 원래의 자료형에서 다른 자료형으로 형 변환 시 발생할 수 있는 오류를 줄일 수 있다.<br>
강제적인 사항은 없지만, 일반적으로 형식 매개변수는 다음과 같이 나타낸다.</p>

<table>
<thead>
<tr>
<th>형식 매개변수 이름</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>요소(Element)</td>
</tr>
<tr>
<td>K</td>
<td>키(Key)</td>
</tr>
<tr>
<td>N</td>
<td>숫자(Number)</td>
</tr>
<tr>
<td>T</td>
<td>형식(Type)</td>
</tr>
<tr>
<td>V</td>
<td>값(Value)</td>
</tr>
<tr>
<td>S, U, V etc.</td>
<td>두 번째, 세 번째, 네 번째 형식…</td>
</tr>
</tbody>
</table><p>이와 같은 제네릭을 사용하면, 인자의 자료형을 고정할 수 없거나 예측할 수 없을 때 형식 매개변수인 T를 사용해 실행 시간에 자료형을 결정할 수 있게 된다.</p>
<h4 id="제네릭-클래스">제네릭 클래스</h4>
<p>제네릭 클래스는 형식 매개변수를 하나 이상 받는 클래스이다.<br>
인스턴스를 생성하는 시점에서 클래스의 자료형을 정한다.<br>
제네릭 클래스 내의 메서드에도 형식 매개변수를 사용할 수 있다.<br>
프로퍼티에 형식 매개변수를 사용하는 경우, 자료형이 특정되지 못하므로 인스턴스를 생성할 수 없어 클래스 내부에서는 사용할 수 없다.<br>
그 대신 <code>class MyClass&lt;T&gt;(val myProp: T) { ... }</code> 과 같이 주 생성자나 부 생성자에 형식 매개변수를 지정해 사용할 수 있다.</p>
<h4 id="제네릭-casting">제네릭 Casting</h4>
<p>상위 클래스인 Parent가 있고, 하위 클래스인 Child가 있을 때, 일반적으로 상위 클래스와 하위 클래스의 형식으로 자연스럽게 변환될 수 있다.<br>
<code>val obj1: Parent = Child()</code><br>
하지만 제네릭 클래스는 가변성을 지정하지 않으면 형식 매개변수에 상,하위 클래스가 지정되어도 서로 자료형이 변환되지 않는다.</p>
<pre><code>val obj2: Cup&lt;Parent&gt; = Cup&lt;Child&gt;( ) //불가
val obj3: Cup&lt;Child&gt; = Cup&lt;Parent&gt;() //불가
</code></pre>
<p>이처럼 가능하게 하려면 in, out이 필요하다.</p>
<h4 id="형식-매개변수의-null-제어">형식 매개변수의 null 제어</h4>
<p>형식 매개변수는 기본적으로 nullable이다.<br>
<code>val obj1 = Cup&lt;Int?&gt;( )</code> 처럼 선언하면 nullable한 방식으로 선언된다.<br>
형식 매개변수가 nullable 하지 않게 하려면, 클래스 선언시<br>
<code>class NotNull&lt;T: Any&gt;{...}</code>처럼 형식 매개변수의 자료형을 Any로 지정하면 null을 허용하지 않는다.</p>
<h4 id="제네릭-메서드">제네릭 메서드</h4>
<p>형식 매개변수를 받는 메서드<br>
<code>fun &lt;K, V&gt; put(key; K, value: V): Unit { ... }</code>같은 애들</p>
<h4 id="제네릭과-람다식">제네릭과 람다식</h4>
<p>형식 매개변수로 선언된 함수의 매개변수를 연산하면, 자료형을 결정할 수 없기 때문에 오류가 생긴다. 이때 람다식을 사용하면 해결할 수 있다.</p>
<pre><code>fun &lt;T&gt; add(a: T, b: T, op: (T, T) -&gt; T): T {
	return op(a, b)
}
fun main() {
	val result = add(2,3,{a , b -&gt; a + b })
	println(result)
}
</code></pre>
<p>하지만 다음과 같이 람다식을 변수로 따로 정의하는 경우는 사용할 수 없다.<br>
<code>var add: (T, T) -&gt; T = {a,b -&gt; a + b} //불가능!</code></p>
<h3 id="자료형-제한하기">자료형 제한하기</h3>
<p>코틀린의 형식 매개변수에는 콜론을 붙여 자료형을 제한시킨다.<br>
<code>class Calc&lt;T: Number&gt; { ... }</code> 처럼 클래스를 선언하면, Int, Double, Long 등 숫자형의 자료형만 객체를 생성할 수 있다.<br>
<code>val str = Calc&lt;String&gt;( )//불가능!</code><br>
함수를 선언할때도 위와 같이</p>
<pre><code>fun&lt;T: Number&gt; addLimit(a: T, b: T, op: (T, T) -&gt; T): T {
	return op(a, b)
}
</code></pre>
<p>함수의 형식 매개변수 옆에 콜론을 붙여 제한한다.</p>
<h4 id="다수-조건의-형식-매개변수-제한하기">다수 조건의 형식 매개변수 제한하기</h4>
<p>특정 여러 개의 상위 클래스(인터페이스, 추상클래스, 오픈클래스 등등…), 혹은 자료형 등의 제한이 여러개인 경우 <strong>where</strong>키워드를 사용해 제한사항을 지정할 수 있다.<br>
<code>class ClassLimit&lt;T&gt; where T:InterfaceA, I:InterfaceB</code><br>
처럼 사용하여 제한할 수 있다.</p>
<p>함수에서도</p>
<pre><code>fun &lt;T&gt; myMax(a: T, b: T): T where T:Number, T:Comparable&lt;T&gt; {
	return if (a &gt; b) a else b
}
</code></pre>
<p>처럼 함수의 return 값 옆에 (없으면 그냥) <strong>where</strong>를 붙여 제한할 수 있다.</p>
<h3 id="상ㆍ하위-형식의-가변성">상ㆍ하위 형식의 가변성</h3>
<p>가변성이란 형식 클래스가 클래스 계층에 영향을 주는 것을 말한다.<br>
우리가 사용하는 클래스는 모두 자료형으로 취급한다!<br>
하지만 nullable한 자료형인 String? 클래스라고 하지 않는다!<br>
List : 클래스! 자료형!<br>
List :  클래스 아님! 자료형만 맞음!<br>
왜 이런 식으로 구분할까?<br>
그것은 클래스는 상, 하위라는 계층 방식을 가지고 있기 때문이다.<br>
예를 들면, Int 클래스는 Number 클래스의 하위 클래스이다.</p>
<pre><code>val inerger: Int = 1
val number: Number = integer // ㅆㄱㄴ
</code></pre>
<p>또한 int는 int? 의 하위 자료형이기도 하다. 위에꺼에서 Number -&gt; int? 해도 ㅆㄱㄴ</p>
<h4 id="가변성의-3가지-유형">가변성의 3가지 유형</h4>
<p>가변성은 형식 매개변수가 클래스 계층에 어떤 영향을 미치는지에 따라 3가지로 나타낼 수 있다.</p>

<table>
<thead>
<tr>
<th>용어</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>공변성(Covariance)</td>
<td>T’가 T의 하위 자료형이면, C&lt;T’&gt;는 C&lt;T&gt;의 하위 자료형이다. 생산자 입장의 Out 성질</td>
</tr>
<tr>
<td>반공변성(Contravariance)</td>
<td>T’가 T의 하위 자료형이면, C&lt;T&gt;는 C&lt;T’&gt;의 하위 자료형이다. 소비자 입장의 in성질</td>
</tr>
<tr>
<td>무변성(Invariance)</td>
<td>C&lt;T&gt;와 C&lt;T’&gt;는 아무런 관계가 없다. 생산자 + 소비자</td>
</tr>
</tbody>
</table><p><a href="https://jinn-blog.tistory.com/21">참고링크</a></p>
<h4 id="무변성">무변성</h4>
<p>제네릭 클래스의 형식 매개변수에 in이나 out등으로 공변성이나 반공변성을 따로 지정하지 않으면, 무변성으로 제네릭 클래스가 선언된다.<br>
제네릭 클래스가 무변성으로 선언되면,<br>
<code>val anys: Box&lt;Any&gt; = Box&lt;Int&gt;(10)</code><br>
같은 경우 상하관계를 잘 따졌음에도 불구하고 Box가 무변성이므로 오류가 발생하게 된다.</p>
<h4 id="공변성">공변성</h4>
<p>형식 매개변수에 상하 자료형 관계가 성립하고 그 관계가 그대로 인스턴스 자료형 관계로 이어지는 경우 <strong>out</strong></p>
<pre><code>class Box&lt;out T&gt;(val size: Int)

val anys: Box&lt;Any&gt; = Box&lt;Int&gt;(10) // OK
val nothings: Box&lt;Nothing&gt; = Box&lt;Int&gt;(20) // X, 자료형 불일치
</code></pre>
<h4 id="반공변성">반공변성</h4>
<p>형식 매개변수에 하-상 자료형 관계(상하 자료형 관계의 반대)가 성립하여, 인스턴스의 자료형이 상위 자료형이 될 때.  <strong>in</strong></p>
<pre><code>class Box&lt;out T&gt;(val size: Int)

val anys: Box&lt;Any&gt; = Box&lt;Int&gt;(10) // X, 자료형 불일치
val nothings: Box&lt;Nothing&gt; = Box&lt;Int&gt;(20) // OK
</code></pre>
<p><strong>상하면 out, 하상이면 in</strong></p>
<h4 id="공변성에-따른-자료형-제한하기">공변성에 따른 자료형 제한하기</h4>
<blockquote>
<p>section3_VarianceLimitTest.kt</p>
</blockquote>
<p>out을 사용하는 경우의 형식 매개변를 갖는 프로퍼티는 var로 지정될 수 없고 val만 허용한다. var을 사용하려면 아래와 같이 지정한다.<br>
<code>class Box&lt;out T: Animal&gt;(private var elem: T)</code></p>
<h3 id="자료형-프로젝션">자료형 프로젝션</h3>
<h4 id="가변성의-2가지-방법">가변성의 2가지 방법</h4>
<ul>
<li>선언 지점 변성<br>
클래스를 선언하면서 클래스 자체에 가변성을 지정하는 방식(in/out)</li>
<li>사용 지점 변성<br>
메서드 배개변수에서 또는 제네릭 클래스를 생성할 때와 같이 사용 위치에서 가변성을 지정하는 방식. 형식 매개변수를 사용할 때마다 해당 형식 매개변수를 어떤 자료형으로 대체할 지 명시해야 함</li>
</ul>
<h4 id="사용-지점-변성과-자료형-프로텍션">사용 지점 변성과 자료형 프로텍션</h4>
<p><code>class Box&lt;T&gt;(var item: T)</code><br>
무변성의 클래스 Box</p>
<pre><code>fun &lt;T&gt; printObj(box: Box&lt;out animal&gt;){
	val obj: Animal = box.item
	println(obj)
}
</code></pre>
<p>이때 클래스가 무변성이므로, item을 <strong>get</strong>하기 위해서는 <strong>out</strong>이, item을 <strong>set</strong>하기 위해서는 <strong>in</strong>으로 지정되어야 한다.</p>
<p>그래서 box의 자료형을 Box&lt;out Animal&gt;로 지정해 제약을 둔 형태로 사용하고 있다. 이렇게 사용하고자 하는 요소의 특정 자료형에 in 또는 out을 지정해 제한하는 것을 자료형 프로젝션이라고 한다.</p>
<pre><code>fun main(){  
    val animal: Box&lt;Animal&gt; = Box(Animal(10))  
    val cat: Box&lt;Cat&gt; = Box(Cat(10))  //게터를 정의하였으므로 가능
    printObj(cat) //불가능, Box가 무변성이므로 
}
</code></pre>
<h4 id="스타-프로젝션">스타 프로젝션</h4>
<p>in, out을 정하지않고 *를 통해 지정하는 방법.<br>
Box&lt;&gt; 가 Box&lt;Any?&gt;가 되면 모든 자료형의 의미를 담을 수 있음을 의미한다.<br>
Box&lt;&gt;가 Box&lt;*&gt;가 되면 어떤 자료형이라도 들어올 수 있으나 구체적으로 자료형이 결정되고 난 후에는 그 자료형과 하위 자료형의 요소만 담을 수 있도록 제한할 수 있다.<br>
<code>class InOutTest&lt;in T, out U&gt;(t: T, u: U){...}</code><br>
<code>fun starTestFunc(v: InOutTest&lt;*, *&gt;){...}</code><br>
위와 같이 사용할 경우 in으로 정의되어 있는 형식 매개변수는 *로 받으면 <strong>in Nothing</strong>이 되고, out을 *로 받으면 **out Any?**인 것으로 간주한다.<br>
그래서 *을 사용할 때 그 위치에 따라 메서드 호출이 제한될 수 있다.</p>
<h4 id="자료형-프로젝션의-정리">자료형 프로젝션의 정리</h4>

<table>
<thead>
<tr>
<th>종류</th>
<th>예</th>
<th>가변성</th>
<th>제한</th>
</tr>
</thead>
<tbody>
<tr>
<td>out 프로젝션</td>
<td>Box&lt;out Cat&gt;</td>
<td>공변성</td>
<td>형식 매개변수는 세터를 통해 값을 설정하는 것이 제한된다</td>
</tr>
<tr>
<td>in 프로젝션</td>
<td>Box&lt;in Cat&gt;</td>
<td>역공변성</td>
<td>형식 매개변수는 게터를 통해 값을 읽거나 반환하는 것이 제한된다</td>
</tr>
<tr>
<td>스타(*) 프로젝션</td>
<td>Box&lt;*&gt;</td>
<td>모든 인스턴스는 하위 형식이 될 수 있다.</td>
<td>in과 out은 사용 방법에 따라 결정한다.</td>
</tr>
</tbody>
</table><h3 id="reified-자료형">reified 자료형</h3>
<p>형식 매개변수는 런타임에 삭제된다. 형식 매개변수를 함수 내부에서 사용하려면, 함수의 매개변수로 넣어<br>
<code>c: Class&lt;T&gt;</code>처럼 지정해야만 실행 시간에 사라지지 않고 접근할 수 있다.<br>
매개변수로 지정하지 않고 직접 접근하려면, <strong>reified</strong> 키워드를 사용한다.</p>
<ul>
<li>reified 자료형은 inline 함수에서만 사용할 수 있다.</li>
</ul>
<p>//예시링크, p372</p>

