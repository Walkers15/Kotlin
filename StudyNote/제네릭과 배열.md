---


---

<h1 id="제네릭과-배열">제네릭과 배열</h1>
<blockquote>
<p>자료형을 일반화해 내부에서 그 자료형에 맞춰 교체하는 방법 &lt;T&gt;</p>
</blockquote>
<h2 id="제네릭-다루기">제네릭 다루기</h2>
<p>제네릭은 클래스 내부에서 사용할 자료형을 나중에 인스턴스를 생성할 때 확정한다.<br>
제네릭을 사용하면 객체의 자료형을 컴파일할 때 체크하기 때문에, 객체 자료형의 안정성을 높이고 형 변환의 번거로움이 줄어든다.</p>
<h3 id="제네릭의-일반적인-사용-방법">제네릭의 일반적인 사용 방법</h3>
<p>앵글 브레킷 <strong>&lt;&gt;</strong> 사이에 형식 매개변수를 넣어 선언한다.<br>
이때 형식 매개변수는 하나 이상 지정할 수 있다.<br>
형식 매개변수는 자료형을 대표하는 용어로, T와 같이 특정 영문의 대문자로 사용한다.<br>
제네릭을 이용함으로써, 의도하지 않은 자료형의 객체를 지정하는 것을 막고, 객체를 사용할 때 원래의 자료형에서 다른 자료형으로 형 변환 시 발생할 수 있는 오류를 줄일 수 있다.<br>
강제적인 사항은 없지만, 일반적으로 형식 매개변수는 다음과 같이 나타낸다.</p>

<table>
<thead>
<tr>
<th>형식 매개변수 이름</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>요소(Element)</td>
</tr>
<tr>
<td>K</td>
<td>키(Key)</td>
</tr>
<tr>
<td>N</td>
<td>숫자(Number)</td>
</tr>
<tr>
<td>T</td>
<td>형식(Type)</td>
</tr>
<tr>
<td>V</td>
<td>값(Value)</td>
</tr>
<tr>
<td>S, U, V etc.</td>
<td>두 번째, 세 번째, 네 번째 형식…</td>
</tr>
</tbody>
</table><p>이와 같은 제네릭을 사용하면, 인자의 자료형을 고정할 수 없거나 예측할 수 없을 때 형식 매개변수인 T를 사용해 실행 시간에 자료형을 결정할 수 있게 된다.</p>
<h4 id="제네릭-클래스">제네릭 클래스</h4>
<p>제네릭 클래스는 형식 매개변수를 하나 이상 받는 클래스이다.<br>
인스턴스를 생성하는 시점에서 클래스의 자료형을 정한다.<br>
제네릭 클래스 내의 메서드에도 형식 매개변수를 사용할 수 있다.<br>
프로퍼티에 형식 매개변수를 사용하는 경우, 자료형이 특정되지 못하므로 인스턴스를 생성할 수 없어 클래스 내부에서는 사용할 수 없다.<br>
그 대신 <code>class MyClass&lt;T&gt;(val myProp: T) { ... }</code> 과 같이 주 생성자나 부 생성자에 형식 매개변수를 지정해 사용할 수 있다.</p>
<h4 id="제네릭-casting">제네릭 Casting</h4>
<p>상위 클래스인 Parent가 있고, 하위 클래스인 Child가 있을 때, 일반적으로 상위 클래스와 하위 클래스의 형식으로 자연스럽게 변환될 수 있다.<br>
<code>val obj1: Parent = Child()</code><br>
하지만 제네릭 클래스는 가변성을 지정하지 않으면 형식 매개변수에 상,하위 클래스가 지정되어도 서로 자료형이 변환되지 않는다.</p>
<pre><code>val obj2: Cup&lt;Parent&gt; = Cup&lt;Child&gt;( ) //불가
val obj3: Cup&lt;Child&gt; = Cup&lt;Parent&gt;() //불가
</code></pre>
<p>이처럼 가능하게 하려면 in, out이 필요하다.</p>
<h4 id="형식-매개변수의-null-제어">형식 매개변수의 null 제어</h4>
<p>형식 매개변수는 기본적으로 nullable이다.<br>
<code>val obj1 = Cup&lt;Int?&gt;( )</code> 처럼 선언하면 nullable한 방식으로 선언된다.<br>
형식 매개변수가 nullable 하지 않게 하려면, 클래스 선언시<br>
<code>class NotNull&lt;T: Any&gt;{...}</code>처럼 형식 매개변수의 자료형을 Any로 지정하면 null을 허용하지 않는다.</p>
<h4 id="제네릭-메서드">제네릭 메서드</h4>
<p>형식 매개변수를 받는 메서드<br>
<code>fun &lt;K, V&gt; put(key; K, value: V): Unit { ... }</code>같은 애들</p>
<h4 id="제네릭과-람다식">제네릭과 람다식</h4>
<p>형식 매개변수로 선언된 함수의 매개변수를 연산하면, 자료형을 결정할 수 없기 때문에 오류가 생긴다. 이때 람다식을 사용하면 해결할 수 있다.</p>
<pre><code>fun &lt;T&gt; add(a: T, b: T, op: (T, T) -&gt; T): T {
	return op(a, b)
}
fun main() {
	val result = add(2,3,{a , b -&gt; a + b })
	println(result)
}
</code></pre>
<p>하지만 다음과 같이 람다식을 변수로 따로 정의하는 경우는 사용할 수 없다.<br>
<code>var add: (T, T) -&gt; T = {a,b -&gt; a + b} //불가능!</code></p>
<h3 id="자료형-제한하기">자료형 제한하기</h3>
<p>코틀린의 형식 매개변수에는 콜론을 붙여 자료형을 제한시킨다.<br>
<code>class Calc&lt;T: Number&gt; { ... }</code> 처럼 클래스를 선언하면, Int, Double, Long 등 숫자형의 자료형만 객체를 생성할 수 있다.<br>
<code>val str = Calc&lt;String&gt;( )//불가능!</code><br>
함수를 선언할때도 위와 같이</p>
<pre><code>fun&lt;T: Number&gt; addLimit(a: T, b: T, op: (T, T) -&gt; T): T {
	return op(a, b)
}
</code></pre>
<p>함수의 형식 매개변수 옆에 콜론을 붙여 제한한다.</p>
<h4 id="다수-조건의-형식-매개변수-제한하기">다수 조건의 형식 매개변수 제한하기</h4>
<p>특정 여러 개의 상위 클래스(인터페이스, 추상클래스, 오픈클래스 등등…), 혹은 자료형 등의 제한이 여러개인 경우 <strong>where</strong>키워드를 사용해 제한사항을 지정할 수 있다.<br>
<code>class ClassLimit&lt;T&gt; where T:InterfaceA, I:InterfaceB</code><br>
처럼 사용하여 제한할 수 있다.</p>
<p>함수에서도</p>
<pre><code>fun &lt;T&gt; myMax(a: T, b: T): T where T:Number, T:Comparable&lt;T&gt; {
	return if (a &gt; b) a else b
}
</code></pre>
<p>처럼 함수의 return 값 옆에 (없으면 그냥) <strong>where</strong>를 붙여 제한할 수 있다.</p>
<h3 id="상ㆍ하위-형식의-가변성">상ㆍ하위 형식의 가변성</h3>
<p>가변성이란 형식 클래스가 클래스 계층에 영향을 주는 것을 말한다.<br>
우리가 사용하는 클래스는 모두 자료형으로 취급한다!<br>
하지만 nullable한 자료형인 String? 클래스라고 하지 않는다!<br>
List : 클래스! 자료형!<br>
List :  클래스 아님! 자료형만 맞음!<br>
왜 이런 식으로 구분할까?<br>
그것은 클래스는 상, 하위라는 계층 방식을 가지고 있기 때문이다.<br>
예를 들면, Int 클래스는 Number 클래스의 하위 클래스이다.</p>
<pre><code>val inerger: Int = 1
val number: Number = integer // ㅆㄱㄴ
</code></pre>
<p>또한 int는 int? 의 하위 자료형이기도 하다. 위에꺼에서 Number -&gt; int? 해도 ㅆㄱㄴ</p>
<h4 id="가변성의-3가지-유형">가변성의 3가지 유형</h4>
<p>가변성은 형식 매개변수가 클래스 계층에 어떤 영향을 미치는지에 따라 3가지로 나타낼 수 있다.</p>

<table>
<thead>
<tr>
<th>용어</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>공변성(Covariance)</td>
<td>T’가 T의 하위 자료형이면, C&lt;T’&gt;는 C&lt;T&gt;의 하위 자료형이다. 생산자 입장의 Out 성질</td>
</tr>
<tr>
<td>반공변성(Contravariance)</td>
<td>T’가 T의 하위 자료형이면, C&lt;T&gt;는 C&lt;T’&gt;의 하위 자료형이다. 소비자 입장의 in성질</td>
</tr>
<tr>
<td>무변성(Invariance)</td>
<td>C&lt;T&gt;와 C&lt;T’&gt;는 아무런 관계가 없다. 생산자 + 소비자</td>
</tr>
</tbody>
</table><p><a href="https://jinn-blog.tistory.com/21">참고링크</a></p>
<h4 id="무변성">무변성</h4>

